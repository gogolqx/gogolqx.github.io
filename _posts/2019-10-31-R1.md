---
layout: post
title: Data Analysis and Visualization Exercise 1
image: /img/hello_world.jpeg
tags: [R]
---
### names, attributes and list
```
aa <- (1:10)
cc <- seq(1,12, by = 1)
names(cc) <- letters[cc]
names(aa) <- letters[aa]

myList <- (aa,cc)
> myList
[[1]]
 a  b  c  d  e  f  g  h  i  j 
 1  2  3  4  5  6  7  8  9 10 

[[2]]
 a  b  c  d  e  f  g  h  i  j  k  l 
 1  2  3  4  5  6  7  8  9 10 11 12 

> attributes(a)
$names
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"

> attributes(myList[1])
NULL
> attributes(myList[[1]])
$names
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"

```
### Q: difference between vector and factor

factor is a vector that only can contain predefined values. It is used to store categorical data. It has **levels** Like for height there are high, medium and low. Then the levels are 1,2,3 which can be ordered or unordered (genders)

### gl (generate levels)

```
x <- gl(n = 3, k = 10, labels =c('Rita', 'Lord', 'Rito'))
> levels(x)
[1] "Rita" "Lord" "Rito"

```
if we replace the second element, it doesn't work. As we  can only use one of the **predefined** labels.

### rev (reverse)

```
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
> f1
 [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a

```
..
```
f2 <- rev(factor(letters))
> f2
 [1] z y x w v u t s r q p o n m l k j i h g f e d c b a
Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z
```
..
```
f3 <- factor(letters, levels = rev(letters))
> f3
 [1] a b c d e f g h i j k l m n o p q r s t u v w x y z
Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a

rev(f3) #reversing f3 will give f1

```
### matrices

create a 3*4 matrix that contains 1 to 12 and conver it into a dataframe.
```
x <- matrix(1:12, 3, 4)

x <- as.data.frame(x)
> x
  V1 V2 V3 V4
1  1  4  7 10
2  2  5  8 11
3  3  6  9 12
```
create a 10 by 5 matrix, name the rows and columns.
```
m <- matrix(1:50, ncol=5)
rownames(m) <-paste0('row_', 1:nrow(m))
colnames(m) <-paste0('col_', 1:ncol(m))
> m
       col_1 col_2 col_3 col_4 col_5
row_1      1    11    21    31    41
row_2      2    12    22    32    42
row_3      3    13    23    33    43
row_4      4    14    24    34    44
row_5      5    15    25    35    45
row_6      6    16    26    36    46
row_7      7    17    27    37    47
row_8      8    18    28    38    48
row_9      9    19    29    39    49
row_10    10    20    30    40    50

> rowMeans(m)
 row_1  row_2  row_3  row_4  row_5  row_6  row_7  row_8  row_9 row_10 
    21     22     23     24     25     26     27     28     29     30 
> colSums(m)
col_1 col_2 col_3 col_4 col_5 
   55   155   255   355   455 
```
add vector as another **row**
```
m <- rbind(m,seq(60,100,10))
```
generate another matrix with the same dimensions, containing random numbers between 1 and 100.
```
n <- matrix(sample(1:100,length(m),replace =T), ncol = ncol(m))
> n
      [,1] [,2] [,3] [,4] [,5]
 [1,]    8   37    9   37   69
 [2,]   46   29   87   32   45
 [3,]   71    8   40    4   82
 [4,]    9   37   74   52    4
 [5,]  100   18   18   68   74
 [6,]   26   54   46   91   35
 [7,]    5   51   78    3   83
 [8,]   69   95    7   99   54
 [9,]   79   35   82   31   28
[10,]   36   47   31   94   81
```
subtract this matrix n from the matrix m.
compute the columns' **correlation** using the _spearman_ method. Then, plot the resulting correlation matrix.
```
> m <-m-n
> M <- cor(m,method = 'spearman')
```
..
```
install.packages("corrplot")
library("corrplot")
corrplot(M,method = 'number')
```
### data.frame
take a list  to coerce it to a data.frame. Keep in mind : the lengths of the elements should be same.
if not, we need to fix that by inserting NAs.
```
df <- as.data.frame(myList)
names(df) <- LETTERS[1:3] # add column names
> df
   A  B  C
a  1  1  1
b  2  2  2
c  3  3  3
d  4  4  4
e  5  5  5
f  6  6  6
g  7  7  7
h  8  8  8
i  9  9  9
j 10 10 10
k NA 11 11
  NA NA 12
```
create a data.frame with 26 rows like below. 
```
> head(df)
  V1 V2 V3
1  1  4  a
2  2  8  a
3  3 12  c
4  4 16  c
5  5 20  e
6  6 24  e
> tail(df)
   V1  V2 V3
21 21  84  u
22 22  88  u
23 23  92  w
24 24  96  w
25 25 100  y
26 26 104  y

aa <- seq(1,26)
bb <- seq(4,104, by = 4)
cc <- rep(seq(1,26,2),each =2 )
> cc
 [1]  1  1  3  3  5  5  7  7  9  9 11 11 13 13 15 15 17 17 19 19 21 21 23 23 25
[26] 25

df <- data.frame(V1= aa, V2 = bb, V3 = letters[cc])
```
change the row names and column names of data.frame to capital letters.
```
> attributes(df2)
$names
[1] "V1" "V2" "V3"

$class
[1] "data.frame"

$row.names
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26

attr(df2,'names') <- letters[1:3]
attr(df2,'row.names') <- LETTERS[1:26]

# Or through accessor functions

names(df2) <-
rownames(df2) <-
```
<span style="color:Crimson">change the attributes ```class``` to list.</span>
you can see taht data.frame is a class which is build on list. Whereas list itself is **not** a class.
class is a generic mechanisum for a simple OO style of programming in R.
## Combining data.frames
```javascript
df[, 1] <- NULL # first column to NULL
dd <- rev(rep(seq(1,26,2), each = 2))
ee <- seq(0, 1, 1.6, length.out = 26) # seq(from, to, by= )
```